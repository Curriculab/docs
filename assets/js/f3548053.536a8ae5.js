"use strict";(globalThis.webpackChunkcurriculab_docs=globalThis.webpackChunkcurriculab_docs||[]).push([[197],{3598(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>d,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"decisions/user-student-joined-table-inheritance","title":"ADR-003: Single User Table with Joined-Table Inheritance for Student","description":"Decision to use a single User table with joined-table inheritance for the Student profile.","source":"@site/decisions/003-user-student-joined-table-inheritance.md","sourceDirName":"decisions","slug":"/decisions/user-student-joined-table-inheritance","permalink":"/docs/decisions/user-student-joined-table-inheritance","draft":false,"unlisted":false,"editUrl":"https://github.com/Curriculab/docs/edit/main/decisions/003-user-student-joined-table-inheritance.md","tags":[],"version":"current","lastUpdatedAt":1771547468000,"sidebarPosition":3,"frontMatter":{"sidebar_label":"ADR-003: User/Student Inheritance","description":"Decision to use a single User table with joined-table inheritance for the Student profile."},"sidebar":"decisionsSidebar","previous":{"title":"ADR-002: UUID v4 PKs","permalink":"/docs/decisions/uuid-v4-primary-keys"},"next":{"title":"ADR-004: Enrollment Concurrency","permalink":"/docs/decisions/optimistic-concurrency-enrollment"}}');var t=i(4848),r=i(8453);const d={sidebar_label:"ADR-003: User/Student Inheritance",description:"Decision to use a single User table with joined-table inheritance for the Student profile."},c="ADR-003: Single User Table with Joined-Table Inheritance for Student",o={},l=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Consequences",id:"consequences",level:2},{value:"Alternatives Considered",id:"alternatives-considered",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"adr-003-single-user-table-with-joined-table-inheritance-for-student",children:"ADR-003: Single User Table with Joined-Table Inheritance for Student"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Date:"})," 2026-02-19\n",(0,t.jsx)(n.strong,{children:"Status:"})," Accepted"]}),"\n",(0,t.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,t.jsx)(n.p,{children:"Curriculab has six user roles: Student, Instructor, Advisor, Academic Staff, Registrar, and Administrator. All six must:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Authenticate with a username/password or SSO credential."}),"\n",(0,t.jsxs)(n.li,{children:["Generate ",(0,t.jsx)(n.code,{children:"Session"})," and ",(0,t.jsx)(n.code,{children:"AuditLog"})," records that reference a single user identity."]}),"\n",(0,t.jsxs)(n.li,{children:["Potentially own ",(0,t.jsx)(n.code,{children:"ApiConsumer"})," records (for integration roles)."]}),"\n",(0,t.jsxs)(n.li,{children:["Receive ",(0,t.jsx)(n.code,{children:"Notification"})," records."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Students are unique in also carrying an extended profile: ",(0,t.jsx)(n.code,{children:"student_number"}),", ",(0,t.jsx)(n.code,{children:"cumulative_gpa"}),", ",(0,t.jsx)(n.code,{children:"total_credit_hours_completed"}),", ",(0,t.jsx)(n.code,{children:"enrollment_status"}),", ",(0,t.jsx)(n.code,{children:"photo_url"}),", ",(0,t.jsx)(n.code,{children:"admit_date"}),", and relationships to ",(0,t.jsx)(n.code,{children:"EmergencyContact"}),", ",(0,t.jsx)(n.code,{children:"StudentProgram"}),", ",(0,t.jsx)(n.code,{children:"Enrollment"}),", ",(0,t.jsx)(n.code,{children:"Waitlist"}),", and ",(0,t.jsx)(n.code,{children:"Hold"}),". No other role has an equivalent extended profile in the current data model."]}),"\n",(0,t.jsx)(n.p,{children:"The question is how to represent the shared authentication identity and the student-specific profile in the same schema without redundancy or excessive nullable columns."}),"\n",(0,t.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:["A single ",(0,t.jsx)(n.code,{children:"User"})," table"]})," holds all principals regardless of role. A ",(0,t.jsx)(n.code,{children:"role"})," enum column (",(0,t.jsx)(n.code,{children:"student"}),", ",(0,t.jsx)(n.code,{children:"instructor"}),", ",(0,t.jsx)(n.code,{children:"advisor"}),", ",(0,t.jsx)(n.code,{children:"academic_staff"}),", ",(0,t.jsx)(n.code,{children:"registrar"}),", ",(0,t.jsx)(n.code,{children:"administrator"}),") determines permissions. RBAC is enforced at the application layer by checking ",(0,t.jsx)(n.code,{children:"User.role"})," on every request."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"Student"})," is a separate profile table"]})," whose ",(0,t.jsx)(n.code,{children:"id"})," is both its PK and a FK to ",(0,t.jsx)(n.code,{children:"User.id"})," (joined-table inheritance with a shared primary key). A ",(0,t.jsx)(n.code,{children:"Student"})," row always has a corresponding ",(0,t.jsx)(n.code,{children:"User"})," row with ",(0,t.jsx)(n.code,{children:"role = 'student'"}),"; this invariant is enforced by the application, not a DB constraint."]}),"\n",(0,t.jsxs)(n.p,{children:['All cross-entity references that need a "person" (e.g., ',(0,t.jsx)(n.code,{children:"AuditLog.user_id"}),", ",(0,t.jsx)(n.code,{children:"Session.user_id"}),", ",(0,t.jsx)(n.code,{children:"Notification.user_id"}),") reference ",(0,t.jsx)(n.code,{children:"User.id"}),". References that need a student-specific entity (e.g., ",(0,t.jsx)(n.code,{children:"Enrollment.student_id"}),", ",(0,t.jsx)(n.code,{children:"Waitlist.student_id"}),") reference ",(0,t.jsx)(n.code,{children:"Student.id"}),", which is the same UUID value."]}),"\n",(0,t.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Positive"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Single authentication path: login, session management, 2FA, and password reset operate on ",(0,t.jsx)(n.code,{children:"User"})," without branching on role."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Session"}),", ",(0,t.jsx)(n.code,{children:"AuditLog"}),", and ",(0,t.jsx)(n.code,{children:"Notification"})," reference one table (",(0,t.jsx)(n.code,{children:"User"}),") without polymorphism or UNION queries."]}),"\n",(0,t.jsxs)(n.li,{children:["Student-specific columns are in their own table; ",(0,t.jsx)(n.code,{children:"User"})," carries no nullable role-specific columns."]}),"\n",(0,t.jsxs)(n.li,{children:["The shared PK means ",(0,t.jsx)(n.code,{children:"Student.id"})," and ",(0,t.jsx)(n.code,{children:"User.id"})," are the same UUID \u2014 no separate join column needed; JOINs use ",(0,t.jsx)(n.code,{children:"Student.id = User.id"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Adding a new role-specific profile table (e.g., ",(0,t.jsx)(n.code,{children:"InstructorProfile"}),") in the future follows the same pattern without altering ",(0,t.jsx)(n.code,{children:"User"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Negative"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Every student data fetch requires a ",(0,t.jsx)(n.code,{children:"JOIN User ON Student.id = User.id"})," to access email, name, or status."]}),"\n",(0,t.jsxs)(n.li,{children:['The invariant "a ',(0,t.jsx)(n.code,{children:"Student"})," row implies a ",(0,t.jsx)(n.code,{children:"User"})," row with ",(0,t.jsx)(n.code,{children:"role = 'student'"}),'" is enforced by the application layer, not a DB ',(0,t.jsx)(n.code,{children:"CHECK"})," constraint. A bug in user creation code could leave an orphaned ",(0,t.jsx)(n.code,{children:"Student"})," without the correct ",(0,t.jsx)(n.code,{children:"User.role"}),". This should be caught by integration tests."]}),"\n",(0,t.jsx)(n.li,{children:"RBAC is application-enforced, not database-enforced; a misconfigured API route could grant cross-role access."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Neutral"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Instructors, Advisors, and other roles do not have profile tables today. If they acquire extended profile needs, the same joined-table inheritance pattern applies without schema changes to ",(0,t.jsx)(n.code,{children:"User"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"alternatives-considered",children:"Alternatives Considered"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Single table with nullable role-specific columns"}),"\nAll user data in one ",(0,t.jsx)(n.code,{children:"User"})," table, with ",(0,t.jsx)(n.code,{children:"student_number"}),", ",(0,t.jsx)(n.code,{children:"cumulative_gpa"}),", etc. as nullable columns. Simple queries, no JOINs. Rejected because it adds many nullable columns that are meaningless for non-student roles, makes the schema misleading, and creates a wide table that grows each time a role gains new attributes."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Separate authentication table per role"}),"\nEach role has its own table (",(0,t.jsx)(n.code,{children:"Student"}),", ",(0,t.jsx)(n.code,{children:"Instructor"}),", etc.) with its own credential columns. Rejected because it duplicates authentication logic across tables and forces ",(0,t.jsx)(n.code,{children:"Session"}),", ",(0,t.jsx)(n.code,{children:"AuditLog"}),", and ",(0,t.jsx)(n.code,{children:"Notification"})," to use polymorphic foreign keys or UNION queries \u2014 significantly complicating the schema and every API layer that deals with identity."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Class-table inheritance with a polymorphic base"}),"\nA ",(0,t.jsx)(n.code,{children:"Person"})," base table (authentication only) with a ",(0,t.jsx)(n.code,{children:"person_type"})," discriminator, and fully typed subclass tables. Functionally equivalent to the chosen approach but adds a third table level for the common case. The chosen design uses ",(0,t.jsx)(n.code,{children:"User"})," as both the authentication table and the base \u2014 avoiding a separate ",(0,t.jsx)(n.code,{children:"Person"})," table."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:["Role profile as ",(0,t.jsx)(n.code,{children:"jsonb"})," on ",(0,t.jsx)(n.code,{children:"User"})]}),"\nStore student-specific data in a ",(0,t.jsx)(n.code,{children:"profile jsonb"})," column on ",(0,t.jsx)(n.code,{children:"User"}),". Flexible, but loses type safety, queryability (no index on ",(0,t.jsx)(n.code,{children:"student_number"}),"), and schema clarity. Rejected."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453(e,n,i){i.d(n,{R:()=>d,x:()=>c});var s=i(6540);const t={},r=s.createContext(t);function d(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);